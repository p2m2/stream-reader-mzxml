// Generated by <a href="http://scalaxb.org/">scalaxb</a>.
package mzxml

sealed trait FileType

object FileType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[mzxml.FileType]): FileType = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: FileType) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[FileType] = Seq(RAWData, ProcessedData)
}

case object RAWData extends FileType { override def toString = "RAWData" }
case object ProcessedData extends FileType { override def toString = "processedData" }


case class ParentFile(value: scalaxb.DataRecord[Any],
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val fileName = attributes("@fileName").as[java.net.URI]
  lazy val fileType = attributes("@fileType").as[FileType]
  lazy val fileSha1 = attributes("@fileSha1").as[String]
}

      
      


case class MsManufacturer(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends OntologyEntryTypable {
  lazy val category = attributes("@category").as[String]
  lazy val valueAttribute = attributes("@value").as[String]
}

      
      


case class MsMassAnalyzer(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) extends OntologyEntryTypable {
  lazy val category = attributes("@category").as[String]
  lazy val valueAttribute = attributes("@value").as[String]
}

      

case class MsInstrument(msManufacturer: mzxml.MsManufacturer,
  msModel: mzxml.OntologyEntryTypable,
  msIonisation: mzxml.OntologyEntryTypable,
  msMassAnalyzer: mzxml.MsMassAnalyzer,
  msDetector: mzxml.OntologyEntryTypable,
  software: mzxml.Software,
  msResolution: Option[mzxml.OntologyEntryTypable] = None,
  operator: Option[mzxml.Operator] = None,
  msinstrumentsequence1: Seq[mzxml.MsInstrumentSequence1] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val msInstrumentID = attributes.get("@msInstrumentID") map { _.as[Int]}
}

      
      

case class MsInstrumentSequence1(nameValue: mzxml.NamevalueType,
  comment: Option[String] = None)
      


case class DataProcessing(software: mzxml.Software,
  dataprocessingsequence1: Seq[mzxml.DataProcessingSequence1] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val intensityCutoff = attributes.get("@intensityCutoff") map { _.as[Float]}
  lazy val centroided = attributes.get("@centroided") map { _.as[Boolean]}
  lazy val deisotoped = attributes.get("@deisotoped") map { _.as[Boolean]}
  lazy val chargeDeconvoluted = attributes.get("@chargeDeconvoluted") map { _.as[Boolean]}
  lazy val spotIntegration = attributes.get("@spotIntegration") map { _.as[Boolean]}
}

      
      

case class DataProcessingSequence1(processingOperation: mzxml.NamevalueType,
  comment: Option[String] = None)
      


case class Separation(separationTechnique: Seq[mzxml.SeparationTechniqueType] = Nil)
      
      


case class Orientation(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val firstSpotID = attributes("@firstSpotID").as[String]
  lazy val secondSpotID = attributes("@secondSpotID").as[String]
}

      
      


case class Pattern(spottingPattern: mzxml.OntologyEntryTypable,
  orientation: mzxml.Orientation)
      
      


case class Spot(maldiMatrix: mzxml.OntologyEntryTypable,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val spotID = attributes("@spotID").as[String]
  lazy val spotXPosition = attributes("@spotXPosition").as[String]
  lazy val spotYPosition = attributes("@spotYPosition").as[String]
  lazy val spotDiameter = attributes.get("@spotDiameter") map { _.as[BigInt]}
}

      
      


case class Plate(plateManufacturer: mzxml.OntologyEntryTypable,
  plateModel: mzxml.OntologyEntryTypable,
  pattern: Option[mzxml.Pattern] = None,
  spot: Seq[mzxml.Spot] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val plateID = attributes("@plateID").as[BigInt]
  lazy val spotXCount = attributes("@spotXCount").as[BigInt]
  lazy val spotYCount = attributes("@spotYCount").as[BigInt]
}

      
      


case class Robot(robotManufacturer: mzxml.OntologyEntryTypable,
  robotModel: mzxml.OntologyEntryTypable,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val timePerSpot = attributes("@timePerSpot").as[javax.xml.datatype.Duration]
  lazy val deadVolume = attributes.get("@deadVolume") map { _.as[BigInt]}
}

      
      


case class Spotting(plate: Seq[mzxml.Plate] = Nil,
  robot: Option[mzxml.Robot] = None)
      
      


case class MsRun(parentFile: Seq[mzxml.ParentFile] = Nil,
  msInstrument: Seq[mzxml.MsInstrument] = Nil,
  dataProcessing: Seq[mzxml.DataProcessing] = Nil,
  separation: Option[mzxml.Separation] = None,
  spotting: Option[mzxml.Spotting] = None,
  scan: Seq[mzxml.Scan] = Nil,
  sha1: Option[String] = None,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val scanCount = attributes.get("@scanCount") map { _.as[BigInt]}
  lazy val startTime = attributes.get("@startTime") map { _.as[javax.xml.datatype.Duration]}
  lazy val endTime = attributes.get("@endTime") map { _.as[javax.xml.datatype.Duration]}
}

      
      


case class Operator(value: scalaxb.DataRecord[Any],
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val first = attributes("@first").as[String]
  lazy val last = attributes("@last").as[String]
  lazy val phone = attributes.get("@phone") map { _.as[String]}
  lazy val email = attributes.get("@email") map { _.as[String]}
  lazy val URI = attributes.get("@URI") map { _.as[java.net.URI]}
}

      
      

sealed trait Type

object Type {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[mzxml.Type]): Type = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Type) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Type] = Seq(Acquisition, Conversion, Processing)
}

case object Acquisition extends Type { override def toString = "acquisition" }
case object Conversion extends Type { override def toString = "conversion" }
case object Processing extends Type { override def toString = "processing" }


case class Software(value: scalaxb.DataRecord[Any],
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val typeValue = attributes("@type").as[Type]
  lazy val name = attributes("@name").as[String]
  lazy val version = attributes("@version").as[String]
  lazy val completionTime = attributes.get("@completionTime") map { _.as[javax.xml.datatype.XMLGregorianCalendar]}
}

      
      

sealed trait Polarity

object Polarity {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[mzxml.Polarity]): Polarity = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Polarity) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Polarity] = Seq(U43, U45, AnyType)
}

case object U43 extends Polarity { override def toString = "+" }
case object U45 extends Polarity { override def toString = "-" }
case object AnyType extends Polarity { override def toString = "any" }

sealed trait ScanType

object ScanType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[mzxml.ScanType]): ScanType = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ScanType) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ScanType] = Seq(Full, Zoom, SIM, SRM, CRM, Q1, Q3)
}

case object Full extends ScanType { override def toString = "Full" }
case object Zoom extends ScanType { override def toString = "zoom" }
case object SIM extends ScanType { override def toString = "SIM" }
case object SRM extends ScanType { override def toString = "SRM" }
case object CRM extends ScanType { override def toString = "CRM" }
case object Q1 extends ScanType { override def toString = "Q1" }
case object Q3 extends ScanType { override def toString = "Q3" }


case class ScanOrigin(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val parentFileID = attributes("@parentFileID").as[String]
  lazy val num = attributes("@num").as[BigInt]
}

      
      

sealed trait ActivationMethod

object ActivationMethod {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[mzxml.ActivationMethod]): ActivationMethod = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ActivationMethod) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ActivationMethod] = Seq(ETD, ECD, CID, HCD, ETDu43SA)
}

case object ETD extends ActivationMethod { override def toString = "ETD" }
case object ECD extends ActivationMethod { override def toString = "ECD" }
case object CID extends ActivationMethod { override def toString = "CID" }
case object HCD extends ActivationMethod { override def toString = "HCD" }
case object ETDu43SA extends ActivationMethod { override def toString = "ETD+SA" }


case class PrecursorMz(value: Float,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val precursorScanNum = attributes.get("@precursorScanNum") map { _.as[BigInt]}
  lazy val precursorIntensity = attributes("@precursorIntensity").as[Float]
  lazy val precursorCharge = attributes.get("@precursorCharge") map { _.as[BigInt]}
  lazy val possibleCharges = attributes.get("@possibleCharges") map { _.as[String]}
  lazy val windowWideness = attributes.get("@windowWideness") map { _.as[Float]}
  lazy val activationMethod = attributes.get("@activationMethod") map { _.as[ActivationMethod]}
}

      
      


case class Maldi(attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val plateID = attributes("@plateID").as[String]
  lazy val spotID = attributes("@spotID").as[String]
  lazy val laserShootCount = attributes.get("@laserShootCount") map { _.as[BigInt]}
  lazy val laserFrequency = attributes.get("@laserFrequency") map { _.as[javax.xml.datatype.Duration]}
  lazy val laserIntensity = attributes.get("@laserIntensity") map { _.as[BigInt]}
  lazy val collisionGas = attributes.get("@collisionGas") map { _.as[Boolean]}
}

      
      

sealed trait Precision

object Precision {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[mzxml.Precision]): Precision = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: Precision) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[Precision] = Seq(Number32, Number64)
}

case object Number32 extends Precision { override def toString = "32" }
case object Number64 extends Precision { override def toString = "64" }

sealed trait ContentType

object ContentType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[mzxml.ContentType]): ContentType = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: ContentType) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[ContentType] = Seq(Mu47zu45int, Mu47z, Mu47zruler, TOF, Intensity, Su47N, Charge)
}

case object Mu47zu45int extends ContentType { override def toString = "m/z-int" }
case object Mu47z extends ContentType { override def toString = "m/z" }
case object Mu47zruler extends ContentType { override def toString = "m/z ruler" }
case object TOF extends ContentType { override def toString = "TOF" }
case object Intensity extends ContentType { override def toString = "intensity" }
case object Su47N extends ContentType { override def toString = "S/N" }
case object Charge extends ContentType { override def toString = "charge" }

sealed trait CompressionType

object CompressionType {
  def fromString(value: String, scope: scala.xml.NamespaceBinding)(implicit fmt: scalaxb.XMLFormat[mzxml.CompressionType]): CompressionType = fmt.reads(scala.xml.Text(value), Nil) match {
    case Right(x: CompressionType) => x
    case x => throw new RuntimeException(s"fromString returned unexpected value $x for input $value")
  }
  lazy val values: Seq[CompressionType] = Seq(NoneType, Zlib)
}

case object NoneType extends CompressionType { override def toString = "none" }
case object Zlib extends CompressionType { override def toString = "zlib" }


case class Peaks(value: scalaxb.Base64Binary,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val precision = attributes.get("@precision") map { _.as[Precision]}
  lazy val byteOrder = attributes("@byteOrder").as[String]
  lazy val contentType = attributes("@contentType").as[ContentType]
  lazy val compressionType = attributes("@compressionType").as[CompressionType]
  lazy val compressedLen = attributes("@compressedLen").as[Int]
}

      
      


case class Scan(scanOrigin: Seq[mzxml.ScanOrigin] = Nil,
  precursorMz: Seq[mzxml.PrecursorMz] = Nil,
  maldi: Option[mzxml.Maldi] = None,
  peaks: Seq[Option[mzxml.Peaks]] = Nil,
  scansequence1: Seq[mzxml.ScanSequence1] = Nil,
  scan: Seq[mzxml.Scan] = Nil,
  attributes: Map[String, scalaxb.DataRecord[Any]] = Map.empty) {
  lazy val num = attributes("@num").as[BigInt]
  lazy val msLevel = attributes("@msLevel").as[BigInt]
  lazy val peaksCount = attributes("@peaksCount").as[BigInt]
  lazy val polarity = attributes.get("@polarity") map { _.as[Polarity]}
  lazy val scanType = attributes.get("@scanType") map { _.as[ScanType]}
  lazy val filterLine = attributes.get("@filterLine") map { _.as[String]}
  lazy val centroided = attributes.get("@centroided") map { _.as[Boolean]}
  lazy val deisotoped = attributes.get("@deisotoped") map { _.as[Boolean]}
  lazy val chargeDeconvoluted = attributes("@chargeDeconvoluted").as[Boolean]
  lazy val retentionTime = attributes.get("@retentionTime") map { _.as[javax.xml.datatype.Duration]}
  lazy val ionisationEnergy = attributes.get("@ionisationEnergy") map { _.as[Float]}
  lazy val collisionEnergy = attributes.get("@collisionEnergy") map { _.as[Float]}
  lazy val cidGasPressure = attributes.get("@cidGasPressure") map { _.as[Float]}
  lazy val startMz = attributes.get("@startMz") map { _.as[Float]}
  lazy val endMz = attributes.get("@endMz") map { _.as[Float]}
  lazy val lowMz = attributes.get("@lowMz") map { _.as[Float]}
  lazy val highMz = attributes.get("@highMz") map { _.as[Float]}
  lazy val basePeakMz = attributes.get("@basePeakMz") map { _.as[Float]}
  lazy val basePeakIntensity = attributes.get("@basePeakIntensity") map { _.as[Float]}
  lazy val totIonCurrent = attributes.get("@totIonCurrent") map { _.as[Float]}
  lazy val msInstrumentID = attributes.get("@msInstrumentID") map { _.as[Int]}
  lazy val compensationVoltage = attributes.get("@compensationVoltage") map { _.as[Float]}
}

      
      

case class ScanSequence1(nameValue: mzxml.NamevalueType,
  comment: Option[String] = None)
      

