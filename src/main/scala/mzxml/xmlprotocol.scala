// Generated by <a href="http://scalaxb.org/">scalaxb</a>.
package mzxml

import scala.concurrent.{ Future, ExecutionContext }


/**
usage:
val obj = scalaxb.fromXML[mzxml.Foo](node)
val document = scalaxb.toXML[mzxml.Foo](obj, "foo", mzxml.defaultScope)
**/
object `package` extends XMLProtocol { }

trait XMLProtocol extends scalaxb.XMLStandardTypes {
  val defaultScope = scalaxb.toScope(None -> "http://sashimi.sourceforge.net/schema_revision/mzXML_3.2",
    Some("cff") -> "http://sashimi.sourceforge.net/schema_revision/mzXML_3.2",
    Some("xs") -> "http://www.w3.org/2001/XMLSchema",
    Some("xsi") -> "http://www.w3.org/2001/XMLSchema-instance")
  implicit lazy val Mzxml_FileTypeFormat: scalaxb.XMLFormat[mzxml.FileType] = new DefaultMzxml_FileTypeFormat {}
  implicit lazy val Mzxml_ParentFileFormat: scalaxb.XMLFormat[mzxml.ParentFile] = new DefaultMzxml_ParentFileFormat {}
  implicit lazy val Mzxml_MsManufacturerFormat: scalaxb.XMLFormat[mzxml.MsManufacturer] = new DefaultMzxml_MsManufacturerFormat {}
  implicit lazy val Mzxml_MsMassAnalyzerFormat: scalaxb.XMLFormat[mzxml.MsMassAnalyzer] = new DefaultMzxml_MsMassAnalyzerFormat {}
  implicit lazy val Mzxml_MsInstrumentFormat: scalaxb.XMLFormat[mzxml.MsInstrument] = new DefaultMzxml_MsInstrumentFormat {}
  implicit lazy val Mzxml_MsInstrumentSequence1Format: scalaxb.XMLFormat[mzxml.MsInstrumentSequence1] = new DefaultMzxml_MsInstrumentSequence1Format {}
  implicit lazy val Mzxml_DataProcessingFormat: scalaxb.XMLFormat[mzxml.DataProcessing] = new DefaultMzxml_DataProcessingFormat {}
  implicit lazy val Mzxml_DataProcessingSequence1Format: scalaxb.XMLFormat[mzxml.DataProcessingSequence1] = new DefaultMzxml_DataProcessingSequence1Format {}
  implicit lazy val Mzxml_SeparationFormat: scalaxb.XMLFormat[mzxml.Separation] = new DefaultMzxml_SeparationFormat {}
  implicit lazy val Mzxml_OrientationFormat: scalaxb.XMLFormat[mzxml.Orientation] = new DefaultMzxml_OrientationFormat {}
  implicit lazy val Mzxml_PatternFormat: scalaxb.XMLFormat[mzxml.Pattern] = new DefaultMzxml_PatternFormat {}
  implicit lazy val Mzxml_SpotFormat: scalaxb.XMLFormat[mzxml.Spot] = new DefaultMzxml_SpotFormat {}
  implicit lazy val Mzxml_PlateFormat: scalaxb.XMLFormat[mzxml.Plate] = new DefaultMzxml_PlateFormat {}
  implicit lazy val Mzxml_RobotFormat: scalaxb.XMLFormat[mzxml.Robot] = new DefaultMzxml_RobotFormat {}
  implicit lazy val Mzxml_SpottingFormat: scalaxb.XMLFormat[mzxml.Spotting] = new DefaultMzxml_SpottingFormat {}
  implicit lazy val Mzxml_MsRunFormat: scalaxb.XMLFormat[mzxml.MsRun] = new DefaultMzxml_MsRunFormat {}
  implicit lazy val Mzxml_OperatorFormat: scalaxb.XMLFormat[mzxml.Operator] = new DefaultMzxml_OperatorFormat {}
  implicit lazy val Mzxml_TypeFormat: scalaxb.XMLFormat[mzxml.Type] = new DefaultMzxml_TypeFormat {}
  implicit lazy val Mzxml_SoftwareFormat: scalaxb.XMLFormat[mzxml.Software] = new DefaultMzxml_SoftwareFormat {}
  implicit lazy val Mzxml_PolarityFormat: scalaxb.XMLFormat[mzxml.Polarity] = new DefaultMzxml_PolarityFormat {}
  implicit lazy val Mzxml_ScanTypeFormat: scalaxb.XMLFormat[mzxml.ScanType] = new DefaultMzxml_ScanTypeFormat {}
  implicit lazy val Mzxml_ScanOriginFormat: scalaxb.XMLFormat[mzxml.ScanOrigin] = new DefaultMzxml_ScanOriginFormat {}
  implicit lazy val Mzxml_ActivationMethodFormat: scalaxb.XMLFormat[mzxml.ActivationMethod] = new DefaultMzxml_ActivationMethodFormat {}
  implicit lazy val Mzxml_PrecursorMzFormat: scalaxb.XMLFormat[mzxml.PrecursorMz] = new DefaultMzxml_PrecursorMzFormat {}
  implicit lazy val Mzxml_MaldiFormat: scalaxb.XMLFormat[mzxml.Maldi] = new DefaultMzxml_MaldiFormat {}
  implicit lazy val Mzxml_PrecisionFormat: scalaxb.XMLFormat[mzxml.Precision] = new DefaultMzxml_PrecisionFormat {}
  implicit lazy val Mzxml_ContentTypeFormat: scalaxb.XMLFormat[mzxml.ContentType] = new DefaultMzxml_ContentTypeFormat {}
  implicit lazy val Mzxml_CompressionTypeFormat: scalaxb.XMLFormat[mzxml.CompressionType] = new DefaultMzxml_CompressionTypeFormat {}
  implicit lazy val Mzxml_PeaksFormat: scalaxb.XMLFormat[mzxml.Peaks] = new DefaultMzxml_PeaksFormat {}
  implicit lazy val Mzxml_ScanFormat: scalaxb.XMLFormat[mzxml.Scan] = new DefaultMzxml_ScanFormat {}
  implicit lazy val Mzxml_ScanSequence1Format: scalaxb.XMLFormat[mzxml.ScanSequence1] = new DefaultMzxml_ScanSequence1Format {}
  implicit lazy val Mzxml_SeparationTechniqueTypeFormat: scalaxb.XMLFormat[mzxml.SeparationTechniqueType] = new DefaultMzxml_SeparationTechniqueTypeFormat {}
  implicit lazy val Mzxml_NamevalueTypeFormat: scalaxb.XMLFormat[mzxml.NamevalueType] = new DefaultMzxml_NamevalueTypeFormat {}
  implicit lazy val Mzxml_OntologyEntryTypableFormat: scalaxb.XMLFormat[mzxml.OntologyEntryTypable] = new DefaultMzxml_OntologyEntryTypableFormat {}
  implicit lazy val Mzxml_OntologyEntryTypeFormat: scalaxb.XMLFormat[mzxml.OntologyEntryType] = new DefaultMzxml_OntologyEntryTypeFormat {}


  implicit val fromAnySchemaType: scala.xml.Elem => Option[scalaxb.DataRecord[Any]] = {elem =>
    import scalaxb.{Helper, DataRecord, fromXML}

    val ns = Helper.nullOrEmpty(elem.scope.getURI(elem.prefix))
    val key = Some(elem.label)
    val (xsns, xstype) = Helper.instanceType(elem)

    (key, ns) match {
      case (Some("scan"), Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[mzxml.Scan](elem)))
      case (Some("operator"), Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[mzxml.Operator](elem)))
      case (Some("msRun"), Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[mzxml.MsRun](elem)))
      case (Some("software"), Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[mzxml.Software](elem)))
      case (Some("separationTechnique"), Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2") | None) => Some(DataRecord(ns, key, xsns, xstype, fromXML[mzxml.SeparationTechniqueType](elem)))

      case _ => None
    }


  }

  def buildMzxml_FileTypeFormat = new DefaultMzxml_FileTypeFormat {}
  trait DefaultMzxml_FileTypeFormat extends scalaxb.XMLFormat[mzxml.FileType] {
    val targetNamespace: Option[String] = Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): mzxml.FileType =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, mzxml.FileType] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("RAWData")) => mzxml.RAWData
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("processedData")) => mzxml.ProcessedData

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, mzxml.FileType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: mzxml.FileType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultMzxml_ParentFileFormat extends scalaxb.XMLFormat[mzxml.ParentFile] with scalaxb.CanWriteChildNodes[mzxml.ParentFile] {
    val targetNamespace: Option[String] = Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2")
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, mzxml.ParentFile] = seq match {
      case node: scala.xml.Node => Right(mzxml.ParentFile(scalaxb.fromXML[scalaxb.DataRecord[Any]](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@fileName").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@fileName" -> _ },
        (node \ "@fileType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[mzxml.FileType](x, scalaxb.ElemName(node) :: stack)) } map { "@fileType" -> _ },
        (node \ "@fileSha1").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@fileSha1" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: mzxml.ParentFile, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@fileName", _) => attr = scala.xml.Attribute(null, "fileName", __obj.fileName.toString, attr)
        case ("@fileType", _) => attr = scala.xml.Attribute(null, "fileType", __obj.fileType.toString, attr)
        case ("@fileSha1", _) => attr = scala.xml.Attribute(null, "fileSha1", __obj.fileSha1.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: mzxml.ParentFile, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.value.value match {
        case elem: scala.xml.Elem => elem.child
        case _ => Seq(scala.xml.Text(__obj.value.value.toString))
      }


  }

  trait DefaultMzxml_MsManufacturerFormat extends scalaxb.XMLFormat[mzxml.MsManufacturer] with scalaxb.CanWriteChildNodes[mzxml.MsManufacturer] {
    val targetNamespace: Option[String] = Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2")
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, mzxml.MsManufacturer] = seq match {
      case node: scala.xml.Node => Right(mzxml.MsManufacturer(scala.collection.immutable.ListMap(List(
        (node \ "@category").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@category" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: mzxml.MsManufacturer, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@category", _) => attr = scala.xml.Attribute(null, "category", __obj.category.toString, attr)
        case ("@value", _) => attr = scala.xml.Attribute(null, "value", __obj.valueAttribute.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: mzxml.MsManufacturer, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMzxml_MsMassAnalyzerFormat extends scalaxb.XMLFormat[mzxml.MsMassAnalyzer] with scalaxb.CanWriteChildNodes[mzxml.MsMassAnalyzer] {
    val targetNamespace: Option[String] = Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2")
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, mzxml.MsMassAnalyzer] = seq match {
      case node: scala.xml.Node => Right(mzxml.MsMassAnalyzer(scala.collection.immutable.ListMap(List(
        (node \ "@category").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@category" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: mzxml.MsMassAnalyzer, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@category", _) => attr = scala.xml.Attribute(null, "category", __obj.category.toString, attr)
        case ("@value", _) => attr = scala.xml.Attribute(null, "value", __obj.valueAttribute.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: mzxml.MsMassAnalyzer, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMzxml_MsInstrumentFormat extends scalaxb.ElemNameParser[mzxml.MsInstrument] {
    val targetNamespace: Option[String] = Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[mzxml.MsInstrument] =
      phrase((scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "msManufacturer")) ~ 
      (scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "msModel")) ~ 
      (scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "msIonisation")) ~ 
      (scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "msMassAnalyzer")) ~ 
      (scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "msDetector")) ~ 
      (scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "software")) ~ 
      opt(scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "msResolution")) ~ 
      opt(scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "operator")) ~ 
      safeRep(((scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "nameValue")) ~ 
      opt(scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "comment"))) ^^ 
        { case p1 ~ p2 => mzxml.MsInstrumentSequence1(scalaxb.fromXML[mzxml.NamevalueType](p1, scalaxb.ElemName(node) :: stack),
        p2.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) }) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 =>
      mzxml.MsInstrument(scalaxb.fromXML[mzxml.MsManufacturer](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[mzxml.OntologyEntryTypable](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[mzxml.OntologyEntryTypable](p3, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[mzxml.MsMassAnalyzer](p4, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[mzxml.OntologyEntryTypable](p5, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[mzxml.Software](p6, scalaxb.ElemName(node) :: stack),
        p7.headOption map { scalaxb.fromXML[mzxml.OntologyEntryTypable](_, scalaxb.ElemName(node) :: stack) },
        p8.headOption map { scalaxb.fromXML[mzxml.Operator](_, scalaxb.ElemName(node) :: stack) },
        p9,
        scala.collection.immutable.ListMap(List(
        (node \ "@msInstrumentID").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Int](x, scalaxb.ElemName(node) :: stack)) } map { "@msInstrumentID" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: mzxml.MsInstrument, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@msInstrumentID", _) => __obj.msInstrumentID foreach { x => attr = scala.xml.Attribute(null, "msInstrumentID", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: mzxml.MsInstrument, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[mzxml.MsManufacturer](__obj.msManufacturer, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("msManufacturer"), __scope, false),
        scalaxb.toXML[mzxml.OntologyEntryTypable](__obj.msModel, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("msModel"), __scope, false),
        scalaxb.toXML[mzxml.OntologyEntryTypable](__obj.msIonisation, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("msIonisation"), __scope, false),
        scalaxb.toXML[mzxml.MsMassAnalyzer](__obj.msMassAnalyzer, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("msMassAnalyzer"), __scope, false),
        scalaxb.toXML[mzxml.OntologyEntryTypable](__obj.msDetector, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("msDetector"), __scope, false),
        scalaxb.toXML[mzxml.Software](__obj.software, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("software"), __scope, false),
        __obj.msResolution map { scalaxb.toXML[mzxml.OntologyEntryTypable](_, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("msResolution"), __scope, false) } getOrElse {Nil},
        __obj.operator map { scalaxb.toXML[mzxml.Operator](_, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("operator"), __scope, false) } getOrElse {Nil},
        __obj.msinstrumentsequence1 flatMap { scalaxb.toXML[mzxml.MsInstrumentSequence1](_, None, Some("msinstrumentsequence1"), __scope, false) })

  }

  trait DefaultMzxml_MsInstrumentSequence1Format extends scalaxb.XMLFormat[mzxml.MsInstrumentSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, mzxml.MsInstrumentSequence1] = Left("don't call me.")
    
    def writes(__obj: mzxml.MsInstrumentSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[mzxml.NamevalueType](__obj.nameValue, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("nameValue"), __scope, false),
        __obj.comment map { scalaxb.toXML[String](_, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("comment"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultMzxml_DataProcessingFormat extends scalaxb.ElemNameParser[mzxml.DataProcessing] {
    val targetNamespace: Option[String] = Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[mzxml.DataProcessing] =
      phrase((scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "software")) ~ 
      safeRep(((scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "processingOperation")) ~ 
      opt(scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "comment"))) ^^ 
        { case p1 ~ p2 => mzxml.DataProcessingSequence1(scalaxb.fromXML[mzxml.NamevalueType](p1, scalaxb.ElemName(node) :: stack),
        p2.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) }) ^^
      { case p1 ~ p2 =>
      mzxml.DataProcessing(scalaxb.fromXML[mzxml.Software](p1, scalaxb.ElemName(node) :: stack),
        p2,
        scala.collection.immutable.ListMap(List(
        (node \ "@intensityCutoff").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Float](x, scalaxb.ElemName(node) :: stack)) } map { "@intensityCutoff" -> _ },
        (node \ "@centroided").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } map { "@centroided" -> _ },
        (node \ "@deisotoped").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } map { "@deisotoped" -> _ },
        (node \ "@chargeDeconvoluted").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } map { "@chargeDeconvoluted" -> _ },
        (node \ "@spotIntegration").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } map { "@spotIntegration" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: mzxml.DataProcessing, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@intensityCutoff", _) => __obj.intensityCutoff foreach { x => attr = scala.xml.Attribute(null, "intensityCutoff", x.toString, attr) }
        case ("@centroided", _) => __obj.centroided foreach { x => attr = scala.xml.Attribute(null, "centroided", x.toString, attr) }
        case ("@deisotoped", _) => __obj.deisotoped foreach { x => attr = scala.xml.Attribute(null, "deisotoped", x.toString, attr) }
        case ("@chargeDeconvoluted", _) => __obj.chargeDeconvoluted foreach { x => attr = scala.xml.Attribute(null, "chargeDeconvoluted", x.toString, attr) }
        case ("@spotIntegration", _) => __obj.spotIntegration foreach { x => attr = scala.xml.Attribute(null, "spotIntegration", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: mzxml.DataProcessing, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[mzxml.Software](__obj.software, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("software"), __scope, false),
        __obj.dataprocessingsequence1 flatMap { scalaxb.toXML[mzxml.DataProcessingSequence1](_, None, Some("dataprocessingsequence1"), __scope, false) })

  }

  trait DefaultMzxml_DataProcessingSequence1Format extends scalaxb.XMLFormat[mzxml.DataProcessingSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, mzxml.DataProcessingSequence1] = Left("don't call me.")
    
    def writes(__obj: mzxml.DataProcessingSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[mzxml.NamevalueType](__obj.processingOperation, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("processingOperation"), __scope, false),
        __obj.comment map { scalaxb.toXML[String](_, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("comment"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultMzxml_SeparationFormat extends scalaxb.ElemNameParser[mzxml.Separation] {
    val targetNamespace: Option[String] = Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[mzxml.Separation] =
      phrase(safeRep(scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "separationTechnique")) ^^
      { case p1 =>
      mzxml.Separation(p1 map { scalaxb.fromXML[mzxml.SeparationTechniqueType](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: mzxml.Separation, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.separationTechnique flatMap { scalaxb.toXML[mzxml.SeparationTechniqueType](_, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("separationTechnique"), __scope, false) })

  }

  trait DefaultMzxml_OrientationFormat extends scalaxb.XMLFormat[mzxml.Orientation] with scalaxb.CanWriteChildNodes[mzxml.Orientation] {
    val targetNamespace: Option[String] = Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2")
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, mzxml.Orientation] = seq match {
      case node: scala.xml.Node => Right(mzxml.Orientation(scala.collection.immutable.ListMap(List(
        (node \ "@firstSpotID").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@firstSpotID" -> _ },
        (node \ "@secondSpotID").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@secondSpotID" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: mzxml.Orientation, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@firstSpotID", _) => attr = scala.xml.Attribute(null, "firstSpotID", __obj.firstSpotID.toString, attr)
        case ("@secondSpotID", _) => attr = scala.xml.Attribute(null, "secondSpotID", __obj.secondSpotID.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: mzxml.Orientation, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMzxml_PatternFormat extends scalaxb.ElemNameParser[mzxml.Pattern] {
    val targetNamespace: Option[String] = Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[mzxml.Pattern] =
      phrase((scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "spottingPattern")) ~ 
      (scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "orientation")) ^^
      { case p1 ~ p2 =>
      mzxml.Pattern(scalaxb.fromXML[mzxml.OntologyEntryTypable](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[mzxml.Orientation](p2, scalaxb.ElemName(node) :: stack)) })
    
    def writesChildNodes(__obj: mzxml.Pattern, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[mzxml.OntologyEntryTypable](__obj.spottingPattern, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("spottingPattern"), __scope, false),
        scalaxb.toXML[mzxml.Orientation](__obj.orientation, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("orientation"), __scope, false))

  }

  trait DefaultMzxml_SpotFormat extends scalaxb.ElemNameParser[mzxml.Spot] {
    val targetNamespace: Option[String] = Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[mzxml.Spot] =
      phrase((scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "maldiMatrix")) ^^
      { case p1 =>
      mzxml.Spot(scalaxb.fromXML[mzxml.OntologyEntryTypable](p1, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@spotID").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@spotID" -> _ },
        (node \ "@spotXPosition").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@spotXPosition" -> _ },
        (node \ "@spotYPosition").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@spotYPosition" -> _ },
        (node \ "@spotDiameter").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@spotDiameter" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: mzxml.Spot, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@spotID", _) => attr = scala.xml.Attribute(null, "spotID", __obj.spotID.toString, attr)
        case ("@spotXPosition", _) => attr = scala.xml.Attribute(null, "spotXPosition", __obj.spotXPosition.toString, attr)
        case ("@spotYPosition", _) => attr = scala.xml.Attribute(null, "spotYPosition", __obj.spotYPosition.toString, attr)
        case ("@spotDiameter", _) => __obj.spotDiameter foreach { x => attr = scala.xml.Attribute(null, "spotDiameter", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: mzxml.Spot, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (scalaxb.toXML[mzxml.OntologyEntryTypable](__obj.maldiMatrix, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("maldiMatrix"), __scope, false))

  }

  trait DefaultMzxml_PlateFormat extends scalaxb.ElemNameParser[mzxml.Plate] {
    val targetNamespace: Option[String] = Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[mzxml.Plate] =
      phrase((scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "plateManufacturer")) ~ 
      (scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "plateModel")) ~ 
      opt(scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "pattern")) ~ 
      safeRep(scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "spot")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      mzxml.Plate(scalaxb.fromXML[mzxml.OntologyEntryTypable](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[mzxml.OntologyEntryTypable](p2, scalaxb.ElemName(node) :: stack),
        p3.headOption map { scalaxb.fromXML[mzxml.Pattern](_, scalaxb.ElemName(node) :: stack) },
        p4 map { scalaxb.fromXML[mzxml.Spot](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@plateID").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@plateID" -> _ },
        (node \ "@spotXCount").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@spotXCount" -> _ },
        (node \ "@spotYCount").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@spotYCount" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: mzxml.Plate, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@plateID", _) => attr = scala.xml.Attribute(null, "plateID", __obj.plateID.toString, attr)
        case ("@spotXCount", _) => attr = scala.xml.Attribute(null, "spotXCount", __obj.spotXCount.toString, attr)
        case ("@spotYCount", _) => attr = scala.xml.Attribute(null, "spotYCount", __obj.spotYCount.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: mzxml.Plate, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[mzxml.OntologyEntryTypable](__obj.plateManufacturer, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("plateManufacturer"), __scope, false),
        scalaxb.toXML[mzxml.OntologyEntryTypable](__obj.plateModel, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("plateModel"), __scope, false),
        __obj.pattern map { scalaxb.toXML[mzxml.Pattern](_, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("pattern"), __scope, false) } getOrElse {Nil},
        __obj.spot flatMap { scalaxb.toXML[mzxml.Spot](_, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("spot"), __scope, false) })

  }

  trait DefaultMzxml_RobotFormat extends scalaxb.ElemNameParser[mzxml.Robot] {
    val targetNamespace: Option[String] = Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[mzxml.Robot] =
      phrase((scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "robotManufacturer")) ~ 
      (scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "robotModel")) ^^
      { case p1 ~ p2 =>
      mzxml.Robot(scalaxb.fromXML[mzxml.OntologyEntryTypable](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[mzxml.OntologyEntryTypable](p2, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@timePerSpot").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.datatype.Duration](x, scalaxb.ElemName(node) :: stack)) } map { "@timePerSpot" -> _ },
        (node \ "@deadVolume").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@deadVolume" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: mzxml.Robot, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@timePerSpot", _) => attr = scala.xml.Attribute(null, "timePerSpot", __obj.timePerSpot.toString, attr)
        case ("@deadVolume", _) => __obj.deadVolume foreach { x => attr = scala.xml.Attribute(null, "deadVolume", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: mzxml.Robot, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[mzxml.OntologyEntryTypable](__obj.robotManufacturer, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("robotManufacturer"), __scope, false),
        scalaxb.toXML[mzxml.OntologyEntryTypable](__obj.robotModel, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("robotModel"), __scope, false))

  }

  trait DefaultMzxml_SpottingFormat extends scalaxb.ElemNameParser[mzxml.Spotting] {
    val targetNamespace: Option[String] = Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[mzxml.Spotting] =
      phrase(safeRep(scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "plate")) ~ 
      opt(scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "robot")) ^^
      { case p1 ~ p2 =>
      mzxml.Spotting(p1 map { scalaxb.fromXML[mzxml.Plate](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[mzxml.Robot](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: mzxml.Spotting, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.plate flatMap { scalaxb.toXML[mzxml.Plate](_, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("plate"), __scope, false) },
        __obj.robot map { scalaxb.toXML[mzxml.Robot](_, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("robot"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMzxml_MsRunFormat extends scalaxb.ElemNameParser[mzxml.MsRun] {
    val targetNamespace: Option[String] = Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[mzxml.MsRun] =
      phrase(safeRep(scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "parentFile")) ~ 
      safeRep(scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "msInstrument")) ~ 
      safeRep(scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "dataProcessing")) ~ 
      opt(scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "separation")) ~ 
      opt(scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "spotting")) ~ 
      safeRep(scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "scan")) ~ 
      opt(scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "sha1")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 =>
      mzxml.MsRun(p1 map { scalaxb.fromXML[mzxml.ParentFile](_, scalaxb.ElemName(node) :: stack) },
        p2 map { scalaxb.fromXML[mzxml.MsInstrument](_, scalaxb.ElemName(node) :: stack) },
        p3 map { scalaxb.fromXML[mzxml.DataProcessing](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[mzxml.Separation](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[mzxml.Spotting](_, scalaxb.ElemName(node) :: stack) },
        p6 map { scalaxb.fromXML[mzxml.Scan](_, scalaxb.ElemName(node) :: stack) },
        p7.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@scanCount").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@scanCount" -> _ },
        (node \ "@startTime").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.datatype.Duration](x, scalaxb.ElemName(node) :: stack)) } map { "@startTime" -> _ },
        (node \ "@endTime").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.datatype.Duration](x, scalaxb.ElemName(node) :: stack)) } map { "@endTime" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: mzxml.MsRun, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@scanCount", _) => __obj.scanCount foreach { x => attr = scala.xml.Attribute(null, "scanCount", x.toString, attr) }
        case ("@startTime", _) => __obj.startTime foreach { x => attr = scala.xml.Attribute(null, "startTime", x.toString, attr) }
        case ("@endTime", _) => __obj.endTime foreach { x => attr = scala.xml.Attribute(null, "endTime", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: mzxml.MsRun, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.parentFile flatMap { scalaxb.toXML[mzxml.ParentFile](_, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("parentFile"), __scope, false) },
        __obj.msInstrument flatMap { scalaxb.toXML[mzxml.MsInstrument](_, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("msInstrument"), __scope, false) },
        __obj.dataProcessing flatMap { scalaxb.toXML[mzxml.DataProcessing](_, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("dataProcessing"), __scope, false) },
        __obj.separation map { scalaxb.toXML[mzxml.Separation](_, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("separation"), __scope, false) } getOrElse {Nil},
        __obj.spotting map { scalaxb.toXML[mzxml.Spotting](_, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("spotting"), __scope, false) } getOrElse {Nil},
        __obj.scan flatMap { scalaxb.toXML[mzxml.Scan](_, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("scan"), __scope, false) },
        __obj.sha1 map { scalaxb.toXML[String](_, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("sha1"), __scope, false) } getOrElse {Nil})

  }

  trait DefaultMzxml_OperatorFormat extends scalaxb.XMLFormat[mzxml.Operator] with scalaxb.CanWriteChildNodes[mzxml.Operator] {
    val targetNamespace: Option[String] = Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2")
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, mzxml.Operator] = seq match {
      case node: scala.xml.Node => Right(mzxml.Operator(scalaxb.fromXML[scalaxb.DataRecord[Any]](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@first").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@first" -> _ },
        (node \ "@last").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@last" -> _ },
        (node \ "@phone").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@phone" -> _ },
        (node \ "@email").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@email" -> _ },
        (node \ "@URI").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[java.net.URI](x, scalaxb.ElemName(node) :: stack)) } map { "@URI" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: mzxml.Operator, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@first", _) => attr = scala.xml.Attribute(null, "first", __obj.first.toString, attr)
        case ("@last", _) => attr = scala.xml.Attribute(null, "last", __obj.last.toString, attr)
        case ("@phone", _) => __obj.phone foreach { x => attr = scala.xml.Attribute(null, "phone", x.toString, attr) }
        case ("@email", _) => __obj.email foreach { x => attr = scala.xml.Attribute(null, "email", x.toString, attr) }
        case ("@URI", _) => __obj.URI foreach { x => attr = scala.xml.Attribute(null, "URI", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: mzxml.Operator, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.value.value match {
        case elem: scala.xml.Elem => elem.child
        case _ => Seq(scala.xml.Text(__obj.value.value.toString))
      }


  }

  def buildMzxml_TypeFormat = new DefaultMzxml_TypeFormat {}
  trait DefaultMzxml_TypeFormat extends scalaxb.XMLFormat[mzxml.Type] {
    val targetNamespace: Option[String] = Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): mzxml.Type =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, mzxml.Type] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("acquisition")) => mzxml.Acquisition
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("conversion")) => mzxml.Conversion
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("processing")) => mzxml.Processing

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, mzxml.Type] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: mzxml.Type, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultMzxml_SoftwareFormat extends scalaxb.XMLFormat[mzxml.Software] with scalaxb.CanWriteChildNodes[mzxml.Software] {
    val targetNamespace: Option[String] = Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2")
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, mzxml.Software] = seq match {
      case node: scala.xml.Node => Right(mzxml.Software(scalaxb.fromXML[scalaxb.DataRecord[Any]](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[mzxml.Type](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ },
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@version").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@version" -> _ },
        (node \ "@completionTime").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.datatype.XMLGregorianCalendar](x, scalaxb.ElemName(node) :: stack)) } map { "@completionTime" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: mzxml.Software, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@type", _) => attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
        case ("@name", _) => attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
        case ("@version", _) => attr = scala.xml.Attribute(null, "version", __obj.version.toString, attr)
        case ("@completionTime", _) => __obj.completionTime foreach { x => attr = scala.xml.Attribute(null, "completionTime", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: mzxml.Software, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.value.value match {
        case elem: scala.xml.Elem => elem.child
        case _ => Seq(scala.xml.Text(__obj.value.value.toString))
      }


  }

  def buildMzxml_PolarityFormat = new DefaultMzxml_PolarityFormat {}
  trait DefaultMzxml_PolarityFormat extends scalaxb.XMLFormat[mzxml.Polarity] {
    val targetNamespace: Option[String] = Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): mzxml.Polarity =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, mzxml.Polarity] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("+")) => mzxml.U43
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("-")) => mzxml.U45
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("any")) => mzxml.AnyType

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, mzxml.Polarity] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: mzxml.Polarity, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMzxml_ScanTypeFormat = new DefaultMzxml_ScanTypeFormat {}
  trait DefaultMzxml_ScanTypeFormat extends scalaxb.XMLFormat[mzxml.ScanType] {
    val targetNamespace: Option[String] = Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): mzxml.ScanType =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, mzxml.ScanType] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Full")) => mzxml.Full
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("zoom")) => mzxml.Zoom
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("SIM")) => mzxml.SIM
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("SRM")) => mzxml.SRM
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("CRM")) => mzxml.CRM
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Q1")) => mzxml.Q1
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("Q3")) => mzxml.Q3

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, mzxml.ScanType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: mzxml.ScanType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultMzxml_ScanOriginFormat extends scalaxb.XMLFormat[mzxml.ScanOrigin] with scalaxb.CanWriteChildNodes[mzxml.ScanOrigin] {
    val targetNamespace: Option[String] = Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2")
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, mzxml.ScanOrigin] = seq match {
      case node: scala.xml.Node => Right(mzxml.ScanOrigin(scala.collection.immutable.ListMap(List(
        (node \ "@parentFileID").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@parentFileID" -> _ },
        (node \ "@num").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@num" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: mzxml.ScanOrigin, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@parentFileID", _) => attr = scala.xml.Attribute(null, "parentFileID", __obj.parentFileID.toString, attr)
        case ("@num", _) => attr = scala.xml.Attribute(null, "num", __obj.num.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: mzxml.ScanOrigin, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  def buildMzxml_ActivationMethodFormat = new DefaultMzxml_ActivationMethodFormat {}
  trait DefaultMzxml_ActivationMethodFormat extends scalaxb.XMLFormat[mzxml.ActivationMethod] {
    val targetNamespace: Option[String] = Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): mzxml.ActivationMethod =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, mzxml.ActivationMethod] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("ETD")) => mzxml.ETD
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("ECD")) => mzxml.ECD
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("CID")) => mzxml.CID
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("HCD")) => mzxml.HCD
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("ETD+SA")) => mzxml.ETDu43SA

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, mzxml.ActivationMethod] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: mzxml.ActivationMethod, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultMzxml_PrecursorMzFormat extends scalaxb.XMLFormat[mzxml.PrecursorMz] with scalaxb.CanWriteChildNodes[mzxml.PrecursorMz] {
    val targetNamespace: Option[String] = Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2")
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, mzxml.PrecursorMz] = seq match {
      case node: scala.xml.Node => Right(mzxml.PrecursorMz(scalaxb.fromXML[Float](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@precursorScanNum").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@precursorScanNum" -> _ },
        (node \ "@precursorIntensity").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Float](x, scalaxb.ElemName(node) :: stack)) } map { "@precursorIntensity" -> _ },
        (node \ "@precursorCharge").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@precursorCharge" -> _ },
        (node \ "@possibleCharges").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@possibleCharges" -> _ },
        (node \ "@windowWideness").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Float](x, scalaxb.ElemName(node) :: stack)) } map { "@windowWideness" -> _ },
        (node \ "@activationMethod").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[mzxml.ActivationMethod](x, scalaxb.ElemName(node) :: stack)) } map { "@activationMethod" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: mzxml.PrecursorMz, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@precursorScanNum", _) => __obj.precursorScanNum foreach { x => attr = scala.xml.Attribute(null, "precursorScanNum", x.toString, attr) }
        case ("@precursorIntensity", _) => attr = scala.xml.Attribute(null, "precursorIntensity", __obj.precursorIntensity.toString, attr)
        case ("@precursorCharge", _) => __obj.precursorCharge foreach { x => attr = scala.xml.Attribute(null, "precursorCharge", x.toString, attr) }
        case ("@possibleCharges", _) => __obj.possibleCharges foreach { x => attr = scala.xml.Attribute(null, "possibleCharges", x.toString, attr) }
        case ("@windowWideness", _) => __obj.windowWideness foreach { x => attr = scala.xml.Attribute(null, "windowWideness", x.toString, attr) }
        case ("@activationMethod", _) => __obj.activationMethod foreach { x => attr = scala.xml.Attribute(null, "activationMethod", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: mzxml.PrecursorMz, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMzxml_MaldiFormat extends scalaxb.XMLFormat[mzxml.Maldi] with scalaxb.CanWriteChildNodes[mzxml.Maldi] {
    val targetNamespace: Option[String] = Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2")
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, mzxml.Maldi] = seq match {
      case node: scala.xml.Node => Right(mzxml.Maldi(scala.collection.immutable.ListMap(List(
        (node \ "@plateID").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@plateID" -> _ },
        (node \ "@spotID").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@spotID" -> _ },
        (node \ "@laserShootCount").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@laserShootCount" -> _ },
        (node \ "@laserFrequency").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.datatype.Duration](x, scalaxb.ElemName(node) :: stack)) } map { "@laserFrequency" -> _ },
        (node \ "@laserIntensity").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@laserIntensity" -> _ },
        (node \ "@collisionGas").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } map { "@collisionGas" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: mzxml.Maldi, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@plateID", _) => attr = scala.xml.Attribute(null, "plateID", __obj.plateID.toString, attr)
        case ("@spotID", _) => attr = scala.xml.Attribute(null, "spotID", __obj.spotID.toString, attr)
        case ("@laserShootCount", _) => __obj.laserShootCount foreach { x => attr = scala.xml.Attribute(null, "laserShootCount", x.toString, attr) }
        case ("@laserFrequency", _) => __obj.laserFrequency foreach { x => attr = scala.xml.Attribute(null, "laserFrequency", x.toString, attr) }
        case ("@laserIntensity", _) => __obj.laserIntensity foreach { x => attr = scala.xml.Attribute(null, "laserIntensity", x.toString, attr) }
        case ("@collisionGas", _) => __obj.collisionGas foreach { x => attr = scala.xml.Attribute(null, "collisionGas", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: mzxml.Maldi, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  def buildMzxml_PrecisionFormat = new DefaultMzxml_PrecisionFormat {}
  trait DefaultMzxml_PrecisionFormat extends scalaxb.XMLFormat[mzxml.Precision] {
    val targetNamespace: Option[String] = Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): mzxml.Precision =
        (fromString0(value, scope)).apply(scalaxb.fromXML[BigInt](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, mzxml.Precision] = {
      case x: BigInt if x == scalaxb.fromXML[BigInt](scala.xml.Text("32")) => mzxml.Number32
      case x: BigInt if x == scalaxb.fromXML[BigInt](scala.xml.Text("64")) => mzxml.Number64

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, mzxml.Precision] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: mzxml.Precision, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMzxml_ContentTypeFormat = new DefaultMzxml_ContentTypeFormat {}
  trait DefaultMzxml_ContentTypeFormat extends scalaxb.XMLFormat[mzxml.ContentType] {
    val targetNamespace: Option[String] = Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): mzxml.ContentType =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, mzxml.ContentType] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("m/z-int")) => mzxml.Mu47zu45int
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("m/z")) => mzxml.Mu47z
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("m/z ruler")) => mzxml.Mu47zruler
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("TOF")) => mzxml.TOF
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("intensity")) => mzxml.Intensity
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("S/N")) => mzxml.Su47N
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("charge")) => mzxml.Charge

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, mzxml.ContentType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: mzxml.ContentType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  def buildMzxml_CompressionTypeFormat = new DefaultMzxml_CompressionTypeFormat {}
  trait DefaultMzxml_CompressionTypeFormat extends scalaxb.XMLFormat[mzxml.CompressionType] {
    val targetNamespace: Option[String] = Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2")
    
    def fromString(value: String, scope: scala.xml.NamespaceBinding): mzxml.CompressionType =
        (fromString0(value, scope)).apply(scalaxb.fromXML[String](scala.xml.Text(value)))

    private def fromString0(value: String, scope: scala.xml.NamespaceBinding): PartialFunction[Any, mzxml.CompressionType] = {
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("none")) => mzxml.NoneType
      case x: String if x == scalaxb.fromXML[String](scala.xml.Text("zlib")) => mzxml.Zlib

    }



    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, mzxml.CompressionType] = seq match {
      case elem: scala.xml.Elem => Right(fromString(elem.text, elem.scope))
      case _ => Right(fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: mzxml.CompressionType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, true, scala.xml.Text(__obj.toString))
  }

  trait DefaultMzxml_PeaksFormat extends scalaxb.XMLFormat[mzxml.Peaks] with scalaxb.CanWriteChildNodes[mzxml.Peaks] {
    val targetNamespace: Option[String] = Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2")
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, mzxml.Peaks] = seq match {
      case node: scala.xml.Node => Right(mzxml.Peaks(scalaxb.fromXML[scalaxb.Base64Binary](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@precision").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[mzxml.Precision](x, scalaxb.ElemName(node) :: stack)) } map { "@precision" -> _ },
        Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[String](scala.xml.Text("network"), scalaxb.ElemName(node) :: stack))) map { "@byteOrder" -> _ },
        (node \ "@contentType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[mzxml.ContentType](x, scalaxb.ElemName(node) :: stack)) } map { "@contentType" -> _ },
        (node \ "@compressionType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[mzxml.CompressionType](x, scalaxb.ElemName(node) :: stack)) } map { "@compressionType" -> _ },
        (node \ "@compressedLen").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Int](x, scalaxb.ElemName(node) :: stack)) } map { "@compressedLen" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: mzxml.Peaks, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@precision", _) => __obj.precision foreach { x => attr = scala.xml.Attribute(null, "precision", x.toString, attr) }
        case ("@byteOrder", _) => attr = scala.xml.Attribute(null, "byteOrder", __obj.byteOrder.toString, attr)
        case ("@contentType", _) => attr = scala.xml.Attribute(null, "contentType", __obj.contentType.toString, attr)
        case ("@compressionType", _) => attr = scala.xml.Attribute(null, "compressionType", __obj.compressionType.toString, attr)
        case ("@compressedLen", _) => attr = scala.xml.Attribute(null, "compressedLen", __obj.compressedLen.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: mzxml.Peaks, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultMzxml_ScanFormat extends scalaxb.ElemNameParser[mzxml.Scan] {
    val targetNamespace: Option[String] = Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[mzxml.Scan] =
      phrase(safeRep(scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "scanOrigin")) ~ 
      safeRep(scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "precursorMz")) ~ 
      opt(scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "maldi")) ~ 
      safeRep(scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "peaks")) ~ 
      safeRep(((scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "nameValue")) ~ 
      opt(scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "comment"))) ^^ 
        { case p1 ~ p2 => mzxml.ScanSequence1(scalaxb.fromXML[mzxml.NamevalueType](p1, scalaxb.ElemName(node) :: stack),
        p2.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) }) ~ 
      safeRep(scalaxb.ElemName(Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), "scan")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      mzxml.Scan(p1 map { scalaxb.fromXML[mzxml.ScanOrigin](_, scalaxb.ElemName(node) :: stack) },
        p2 map { scalaxb.fromXML[mzxml.PrecursorMz](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[mzxml.Maldi](_, scalaxb.ElemName(node) :: stack) },
        p4 map { x => scalaxb.ElemName(x).nilOption map { scalaxb.fromXML[mzxml.Peaks](_, scalaxb.ElemName(node) :: stack) }},
        p5,
        p6 map { scalaxb.fromXML[mzxml.Scan](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap(List(
        (node \ "@num").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@num" -> _ },
        (node \ "@msLevel").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@msLevel" -> _ },
        (node \ "@peaksCount").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[BigInt](x, scalaxb.ElemName(node) :: stack)) } map { "@peaksCount" -> _ },
        (node \ "@polarity").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[mzxml.Polarity](x, scalaxb.ElemName(node) :: stack)) } map { "@polarity" -> _ },
        (node \ "@scanType").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[mzxml.ScanType](x, scalaxb.ElemName(node) :: stack)) } map { "@scanType" -> _ },
        (node \ "@filterLine").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@filterLine" -> _ },
        (node \ "@centroided").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } map { "@centroided" -> _ },
        (node \ "@deisotoped").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } map { "@deisotoped" -> _ },
        (node \ "@chargeDeconvoluted").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Boolean](x, scalaxb.ElemName(node) :: stack)) } orElse Some(scalaxb.DataRecord(None, None, scalaxb.fromXML[Boolean](scala.xml.Text("0"), scalaxb.ElemName(node) :: stack))) map { "@chargeDeconvoluted" -> _ },
        (node \ "@retentionTime").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[javax.xml.datatype.Duration](x, scalaxb.ElemName(node) :: stack)) } map { "@retentionTime" -> _ },
        (node \ "@ionisationEnergy").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Float](x, scalaxb.ElemName(node) :: stack)) } map { "@ionisationEnergy" -> _ },
        (node \ "@collisionEnergy").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Float](x, scalaxb.ElemName(node) :: stack)) } map { "@collisionEnergy" -> _ },
        (node \ "@cidGasPressure").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Float](x, scalaxb.ElemName(node) :: stack)) } map { "@cidGasPressure" -> _ },
        (node \ "@startMz").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Float](x, scalaxb.ElemName(node) :: stack)) } map { "@startMz" -> _ },
        (node \ "@endMz").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Float](x, scalaxb.ElemName(node) :: stack)) } map { "@endMz" -> _ },
        (node \ "@lowMz").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Float](x, scalaxb.ElemName(node) :: stack)) } map { "@lowMz" -> _ },
        (node \ "@highMz").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Float](x, scalaxb.ElemName(node) :: stack)) } map { "@highMz" -> _ },
        (node \ "@basePeakMz").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Float](x, scalaxb.ElemName(node) :: stack)) } map { "@basePeakMz" -> _ },
        (node \ "@basePeakIntensity").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Float](x, scalaxb.ElemName(node) :: stack)) } map { "@basePeakIntensity" -> _ },
        (node \ "@totIonCurrent").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Float](x, scalaxb.ElemName(node) :: stack)) } map { "@totIonCurrent" -> _ },
        (node \ "@msInstrumentID").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Int](x, scalaxb.ElemName(node) :: stack)) } map { "@msInstrumentID" -> _ },
        (node \ "@compensationVoltage").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[Float](x, scalaxb.ElemName(node) :: stack)) } map { "@compensationVoltage" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)) })
    
    override def writesAttribute(__obj: mzxml.Scan, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@num", _) => attr = scala.xml.Attribute(null, "num", __obj.num.toString, attr)
        case ("@msLevel", _) => attr = scala.xml.Attribute(null, "msLevel", __obj.msLevel.toString, attr)
        case ("@peaksCount", _) => attr = scala.xml.Attribute(null, "peaksCount", __obj.peaksCount.toString, attr)
        case ("@polarity", _) => __obj.polarity foreach { x => attr = scala.xml.Attribute(null, "polarity", x.toString, attr) }
        case ("@scanType", _) => __obj.scanType foreach { x => attr = scala.xml.Attribute(null, "scanType", x.toString, attr) }
        case ("@filterLine", _) => __obj.filterLine foreach { x => attr = scala.xml.Attribute(null, "filterLine", x.toString, attr) }
        case ("@centroided", _) => __obj.centroided foreach { x => attr = scala.xml.Attribute(null, "centroided", x.toString, attr) }
        case ("@deisotoped", _) => __obj.deisotoped foreach { x => attr = scala.xml.Attribute(null, "deisotoped", x.toString, attr) }
        case ("@chargeDeconvoluted", _) => if (__obj.chargeDeconvoluted.toString != "0") attr = scala.xml.Attribute(null, "chargeDeconvoluted", __obj.chargeDeconvoluted.toString, attr)
        case ("@retentionTime", _) => __obj.retentionTime foreach { x => attr = scala.xml.Attribute(null, "retentionTime", x.toString, attr) }
        case ("@ionisationEnergy", _) => __obj.ionisationEnergy foreach { x => attr = scala.xml.Attribute(null, "ionisationEnergy", x.toString, attr) }
        case ("@collisionEnergy", _) => __obj.collisionEnergy foreach { x => attr = scala.xml.Attribute(null, "collisionEnergy", x.toString, attr) }
        case ("@cidGasPressure", _) => __obj.cidGasPressure foreach { x => attr = scala.xml.Attribute(null, "cidGasPressure", x.toString, attr) }
        case ("@startMz", _) => __obj.startMz foreach { x => attr = scala.xml.Attribute(null, "startMz", x.toString, attr) }
        case ("@endMz", _) => __obj.endMz foreach { x => attr = scala.xml.Attribute(null, "endMz", x.toString, attr) }
        case ("@lowMz", _) => __obj.lowMz foreach { x => attr = scala.xml.Attribute(null, "lowMz", x.toString, attr) }
        case ("@highMz", _) => __obj.highMz foreach { x => attr = scala.xml.Attribute(null, "highMz", x.toString, attr) }
        case ("@basePeakMz", _) => __obj.basePeakMz foreach { x => attr = scala.xml.Attribute(null, "basePeakMz", x.toString, attr) }
        case ("@basePeakIntensity", _) => __obj.basePeakIntensity foreach { x => attr = scala.xml.Attribute(null, "basePeakIntensity", x.toString, attr) }
        case ("@totIonCurrent", _) => __obj.totIonCurrent foreach { x => attr = scala.xml.Attribute(null, "totIonCurrent", x.toString, attr) }
        case ("@msInstrumentID", _) => __obj.msInstrumentID foreach { x => attr = scala.xml.Attribute(null, "msInstrumentID", x.toString, attr) }
        case ("@compensationVoltage", _) => __obj.compensationVoltage foreach { x => attr = scala.xml.Attribute(null, "compensationVoltage", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: mzxml.Scan, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.scanOrigin flatMap { scalaxb.toXML[mzxml.ScanOrigin](_, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("scanOrigin"), __scope, false) },
        __obj.precursorMz flatMap { scalaxb.toXML[mzxml.PrecursorMz](_, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("precursorMz"), __scope, false) },
        __obj.maldi map { scalaxb.toXML[mzxml.Maldi](_, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("maldi"), __scope, false) } getOrElse {Nil},
        __obj.peaks flatMap { scalaxb.toXML[Option[mzxml.Peaks]](_, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("peaks"), __scope, false) },
        __obj.scansequence1 flatMap { scalaxb.toXML[mzxml.ScanSequence1](_, None, Some("scansequence1"), __scope, false) },
        __obj.scan flatMap { scalaxb.toXML[mzxml.Scan](_, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("scan"), __scope, false) })

  }

  trait DefaultMzxml_ScanSequence1Format extends scalaxb.XMLFormat[mzxml.ScanSequence1] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, mzxml.ScanSequence1] = Left("don't call me.")
    
    def writes(__obj: mzxml.ScanSequence1, __namespace: Option[String], __elementLabel: Option[String], 
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      Seq.concat(scalaxb.toXML[mzxml.NamevalueType](__obj.nameValue, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("nameValue"), __scope, false),
        __obj.comment map { scalaxb.toXML[String](_, Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2"), Some("comment"), __scope, false) } getOrElse {Nil})


  }

  trait DefaultMzxml_SeparationTechniqueTypeFormat extends scalaxb.XMLFormat[mzxml.SeparationTechniqueType] with scalaxb.CanWriteChildNodes[mzxml.SeparationTechniqueType] {
    val targetNamespace: Option[String] = Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2")
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, mzxml.SeparationTechniqueType] = seq match {
      case node: scala.xml.Node => Right(mzxml.SeparationTechniqueType())
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def writesChildNodes(__obj: mzxml.SeparationTechniqueType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultMzxml_NamevalueTypeFormat extends scalaxb.XMLFormat[mzxml.NamevalueType] with scalaxb.CanWriteChildNodes[mzxml.NamevalueType] {
    val targetNamespace: Option[String] = Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2")
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, mzxml.NamevalueType] = seq match {
      case node: scala.xml.Node => Right(mzxml.NamevalueType(scalaxb.fromXML[scalaxb.DataRecord[Any]](node, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap(List(
        (node \ "@name").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@name" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[scalaxb.DataRecord[Any]](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ },
        (node \ "@type").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[scalaxb.DataRecord[Any]](x, scalaxb.ElemName(node) :: stack)) } map { "@type" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: mzxml.NamevalueType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@name", _) => __obj.name foreach { x => attr = scala.xml.Attribute(null, "name", x.toString, attr) }
        case ("@value", _) => __obj.valueAttribute foreach { x => attr = scala.xml.Attribute(null, "value", x.toString, attr) }
        case ("@type", _) => __obj.typeValue foreach { x => attr = scala.xml.Attribute(null, "type", x.toString, attr) }
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: mzxml.NamevalueType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.value.value match {
        case elem: scala.xml.Elem => elem.child
        case _ => Seq(scala.xml.Text(__obj.value.value.toString))
      }


  }

  trait DefaultMzxml_OntologyEntryTypableFormat extends scalaxb.XMLFormat[mzxml.OntologyEntryTypable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, mzxml.OntologyEntryTypable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          
          case _ => Right(scalaxb.fromXML[mzxml.OntologyEntryType](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: mzxml.OntologyEntryTypable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: mzxml.MsMassAnalyzer => scalaxb.toXML[mzxml.MsMassAnalyzer](x, __namespace, __elementLabel, __scope, true)
      case x: mzxml.MsManufacturer => scalaxb.toXML[mzxml.MsManufacturer](x, __namespace, __elementLabel, __scope, true)
      case x: mzxml.OntologyEntryType => scalaxb.toXML[mzxml.OntologyEntryType](x, __namespace, __elementLabel, __scope, __typeAttribute)
    }
  }

  trait DefaultMzxml_OntologyEntryTypeFormat extends scalaxb.XMLFormat[mzxml.OntologyEntryType] with scalaxb.CanWriteChildNodes[mzxml.OntologyEntryType] {
    val targetNamespace: Option[String] = Some("http://sashimi.sourceforge.net/schema_revision/mzXML_3.2")
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, mzxml.OntologyEntryType] = seq match {
      case node: scala.xml.Node => Right(mzxml.OntologyEntryType(scala.collection.immutable.ListMap(List(
        (node \ "@category").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@category" -> _ },
        (node \ "@value").headOption map { x => scalaxb.DataRecord(x, node, scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)) } map { "@value" -> _ }
        ).flatten[(String, scalaxb.DataRecord[Any])]: _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: mzxml.OntologyEntryType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case ("@category", _) => attr = scala.xml.Attribute(null, "category", __obj.category.toString, attr)
        case ("@value", _) => attr = scala.xml.Attribute(null, "value", __obj.valueAttribute.toString, attr)
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr)
      }
      attr
    }

    def writesChildNodes(__obj: mzxml.OntologyEntryType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }


}

